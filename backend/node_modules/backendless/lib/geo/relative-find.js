'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.relativeFind = relativeFind;

var _urls = require('../urls');

var _urls2 = _interopRequireDefault(_urls);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

var _request = require('../request/index');

var _request2 = _interopRequireDefault(_request);

var _point = require('./point');

var _point2 = _interopRequireDefault(_point);

var _queryValidator = require('./query-validator');

var _queryParams = require('./query-params');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//TODO: refactor me

function relativeFind(query, asyncHandler) {
  if (!(query.relativeFindMetadata && query.relativeFindPercentThreshold)) {
    throw new Error('Inconsistent geo query. ' + 'Query should contain both relativeFindPercentThreshold and relativeFindMetadata');
  }

  (0, _queryValidator.validateQueryObject)(query);

  query.url = this.app.urls.geoRelative();

  var url = query.url + (query.searchRectangle ? '/rect' : '/points') + '?' + (0, _queryParams.toQueryParams)(query);

  if (asyncHandler) {
    asyncHandler = _utils2.default.wrapAsync(asyncHandler, function (resp) {
      return responseParser(resp);
    });
  }

  var result = this.app.request.get({
    url: url,
    isAsync: !!asyncHandler,
    asyncHandler: asyncHandler
  });

  if (asyncHandler) {
    return result;
  }

  return responseParser(result);
}

function responseParser(items) {
  return items.map(function (item) {
    return {
      geoPoint: new _point2.default(item.geoPoint),
      matches: item.matches
    };
  });
}