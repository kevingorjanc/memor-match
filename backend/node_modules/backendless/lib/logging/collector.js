'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

var _async = require('../request/async');

var _async2 = _interopRequireDefault(_async);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LoggingCollector = function () {
  /**
   * @param {Backendless} app
   */
  function LoggingCollector(app) {
    _classCallCheck(this, LoggingCollector);

    this.app = app;

    this.url = this.app.urls.logging();

    this.flush = _utils2.default.promisified(this.flush);
    this.flushSync = _utils2.default.synchronized(this.flush);

    this.reset();
  }

  _createClass(LoggingCollector, [{
    key: 'reset',
    value: function reset() {
      this.lastFlushListeners = [];
      this.loggers = {};
      this.pool = [];
      this.numOfMessages = 10;
      this.timeFrequency = 1;
    }
  }, {
    key: 'getLogger',
    value: function getLogger(loggerName) {
      if (!_utils2.default.isString(loggerName)) {
        throw new Error("Invalid 'loggerName' value. LoggerName must be a string value");
      }

      var _require = require('./logger'),
          Logger = _require.default;

      var logger = this.loggers[loggerName] || new Logger(loggerName, this);

      this.loggers[loggerName] = logger;

      return logger;
    }
  }, {
    key: 'push',
    value: function push(logger, logLevel, message, exception) {
      var messageObj = {
        logger: logger,
        message: message,
        exception: exception,
        'log-level': logLevel,
        timestamp: Date.now()
      };

      this.pool.push(messageObj);

      this.checkMessagesLen();
    }
  }, {
    key: 'checkMessagesLen',
    value: function checkMessagesLen() {
      if (this.pool.length >= this.numOfMessages) {
        this.sendRequest();
      }
    }
  }, {
    key: 'sendRequest',
    value: function sendRequest() {
      var _this = this;

      if (!this.flushInterval) {
        this.flushInterval = setTimeout(function () {
          return _this.flush();
        }, this.timeFrequency * 1000);
      }
    }
  }, {
    key: 'setLogReportingPolicy',
    value: function setLogReportingPolicy(numOfMessages, timeFrequency) {
      this.numOfMessages = numOfMessages;
      this.timeFrequency = timeFrequency;

      //TODO: check when set new timeFrequency
      this.checkMessagesLen();
    }
  }, {
    key: 'flush',
    value: function flush(asyncHandler) {
      if (this.pool.length) {
        if (this.flushInterval) {
          clearTimeout(this.flushInterval);
          delete this.flushInterval;
        }

        var listeners = void 0;
        var loggingCollector = this;

        var cb = function cb(method) {
          return function () {
            var _arguments = arguments;

            listeners.forEach(function (callbacks) {
              callbacks[method].apply(null, _arguments);
            });

            if (listeners === loggingCollector.lastFlushListeners) {
              loggingCollector.lastFlushListeners = null;
            }
          };
        };

        if (asyncHandler) {
          listeners = this.lastFlushListeners = this.lastFlushListeners ? this.lastFlushListeners.splice(0) : [];
          listeners.push(asyncHandler);
        }

        this.app.request.put({
          isAsync: !!asyncHandler,
          asyncHandler: asyncHandler && new _async2.default(cb('success'), cb('fault')),
          url: this.url,
          data: this.pool
        });

        this.pool = [];
      } else if (asyncHandler) {
        if (this.lastFlushListeners) {
          this.lastFlushListeners.push(asyncHandler);
        } else {
          setTimeout(asyncHandler.success, 0);
        }
      }
    }
  }]);

  return LoggingCollector;
}();

exports.default = LoggingCollector;